---
name: utility-layered-explainer
description: 同じトピックを「浅い→深い→第一原理」まで一度に段階的に解説する（TL;DR/概要/仕組み/第一原理=Whyの連鎖）。追加の「Why」を何度も要求させず、最初から理解の階段を用意したいときに使う。Use when user asks for deep/first-principles explanations or complains answers are too shallow.
metadata:
  short-description: Layered explanation helper
---

# Layered Explainer Skill

ユーザーの質問に対して、**同じ回答内で**「結論→根拠（How/Why）→次の一手」の形で、浅い→深い→第一原理まで段階的に出す。
特に「なぜそうした？」「何を変えた？（作業内容の説明）」のように、**事実（What）と理由（Why）が混ざりやすい**問いで効果を発揮する。

## 入力（あるだけでOK）

- 質問文（何を・なぜ・どうしたいか）
- 具体例（コード/ログ/エラー文/図）
- 制約（時間、変更できない前提、環境）
- 「何をやったか」を説明する場合: 変更ファイル、差分、実行したコマンド、検証結果

## Workflow

### 0) まずゴールを1行で固定する

- 例: 「原因を理解して直したい」「設計判断の是非を知りたい」「仕組みを腹落ちさせたい」
- 例（作業説明）: 「何を変えたのか（事実）と、なぜそうしたのか（理由）を分けて腹落ちさせたい」
- 不明でも止めず、**推測で置いて進める**（最後に確認質問を最大2つだけ添える）

### 1) 出力は “結論 → 根拠 → 実務” を基本形にする（固定）

4レイヤーを機械的に分けるより、**「結論」「根拠（How/Why）」「次の一手」**の3点を揃える方が伝わりやすい。

#### 結論

- 1〜3文で言い切る（原因→結果→対処、の順が無難）
- 「作業内容の説明」なら `何を変えた(What) → なぜ(Why) → 次に何をする(Next)` を最短で

#### 根拠（How / Why）

- How（仕組み）: 「どの条件で起きるか」を手順/フローで説明（箇条書き or 番号付き）。可能なら **ユーザーの具体例** にマッピングする
- Why（第一原理）: “なぜそう設計/制約/挙動になるか” を掘る（セキュリティ、整合性、性能、運用、コスト）
  - Why は **同一の対象**（現象/判断/制約）に対して「なぜ？」を繰り返して深掘りする（Why1 → Why2 → Why3）
  - NG: 並列に別々の対象へ Why を投げて論点を散らす
  - 分岐が必要なら「分岐候補」を列挙し、代表 1 つを深掘りしてから次へ
- 「作業内容の説明」なら、**Where / What / How verified** を必ず入れる（検証未実行なら「未実行」と明記）:
  - Where: 変更箇所（ファイルパス・関数名・設定キー）。可能なら行番号も添える（例: `path/to/file.ts:42`）
  - What: 具体的に何を変えたか（差分の要点）
  - How verified: どう確かめたか（実行したテスト/コマンド、観測点）。未実行なら代わりに何を確認したかを書く

#### 実務：次に何をする？

- 直すなら何を変えるか（1〜3個）
- 確かめるならどこを見るか（ログ/設定/再現手順/観測点）
- 代替案があるならトレードオフを1行ずつ

### よくある失敗（このスキルのアンチパターン）

- **ファイル名/行番号だけ列挙**して終わる（What はあっても Why/影響がない）
- **理由だけ語って**「結局どこをどう変えたか」が無い（Why はあっても What/Where がない）
- 根拠（How）が抽象的で、ユーザーの具体例・変更箇所にマッピングされていない
- 「検証した」と言い切るのに、実際に何を実行/確認したかが書かれていない

### 2) 追加質問は “深掘りの選択肢” にする（最大2つ）

- 説明の後ろに、追加で答えやすい質問を添える
- 例: 「この話は “ブラウザ” のCORS前提でOK？（サーバー間通信なら別）」

## 出力テンプレ（この形を崩しすぎない）

```markdown
## 結論
...

## 根拠（How / Why）
- How: ...
- Why1: ...
  - Why2: ...
    - Why3: ...

## 実務：次に何をする？
- ...

## 確認（任意）
- ...
```

## ミニ例（CORS + カスタムヘッダー）

- **結論:** クロスオリジンにカスタムヘッダーを付けるとプリフライトが走り、許可が無いと**ブラウザが本リクエストを送らずに止める**。
- **根拠（How）:** `Access-Control-Request-Headers` → `Access-Control-Allow-Headers` を照合し、不一致ならブロック。
- **根拠（Why）:** もし「無視」できると、攻撃者が任意ヘッダー（認可/識別子等）を付けて境界を越えられ、同一オリジン前提（=権限分離）が崩れるため “ホワイトリスト” が必要。

## ミニ例（「何を変えた？」: CLI を非対話で動かす）

- **結論:** 対話UI前提の `codex` / `claude` は非TTYや書き込み制限で落ちるので、`codex exec` と `claude -p`（必要なら `HOME` 退避）にする。
- **根拠（What/Where/Verify）:** Where: `src/skills/.../SKILL.md` の外部レビューコマンド行。What: `codex "...“` → `codex exec "...“`、`claude "...“` → `HOME=... claude -p "...“`。Verify: `rg` で旧コマンドが残っていないことを確認。
